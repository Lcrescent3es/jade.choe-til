## 날짜: 2024-08-08

### 스크럼
  - 없음

### 새로 배운 내용
#### 주제 1: Servlet 객체
- 서블릿은 Java 언어를 기반으로 하는 웹 애플리케이션 개발을 위한 기술이다.
- 서블릿은 클라이언트의 요청에 따라 서버에서 처리하는 자바 객체이다.
- 서블릿은 서블릿 컨테이너 안에서 존재하며, 서블릿 컨테이너는 클라이언트의 최초 요청을 받을 시 서블릿 객체를 init()한다.
- init()된 서블릿 객체는 service()를 호출하여 서버 내에서 클라이언트의 요청을 처리한다.
- 최초가 아닌 클라이언트의 요청이 들어오면, 즉시 service()를 호출한다. (객체 재사용)
- HTTP 프로토콜에서 사용하는 서블릿 객체는 HTTPServlet 클래스로, Response 객체와 Request 객체가 나뉘어져있다.
- 서블릿 객체는 destroy()될때 생명주기가 끝난다.(서비스나 서버 중지시)

<img width="768" alt="image" src="https://github.com/user-attachments/assets/1d4858bb-d84f-48ad-8f53-5c3ed2abb98b">
- 서블릿의 원리 

#### 주제 2: 스프링 Bean
- [레퍼런스](https://ittrue.tistory.com/225)
- 스프링의 Bean은 스프링 컨테이너가 프로그램의 Control을 가져오기 위해 사용하는 인스턴스 개념이다.(Inversion of Control)
- 스프링의 Bean은 각자 스코프를 가지고 있는데, 그 범위는 다음과 같다.
  - 싱글톤: 기본 스코프(Default), 스프링 컨테이너에서 한 번만 생성되며 컨테이너가 사라질 때 제거되는 가장 넓은 범위의 스코프이다.
  - 프로토타입: DI가 발생할 때마다 새로운 객체가 생성되어 의존관계 주입까지만 관여하고 더는 관리하지 않는 짧은 범위의 스코프이다.
  - 웹 관련 스코프
    - request: 웹 요청이 들어오고 나갈 때 까지 유지
    - session: 세션이 생성되고 종료될 때 까지 유지
    - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지
    - websocket: 웹 소켓과 동일한 범위로 유지
- @Controller, @Service, @Repository 어노테이션을 통해 스프링 MVC에서 빈으로 등록이 가능하다.
- configuration 객체들은 @Bean과 @Component로 선언이 가능한데, 
- @Bean은 메소드 레벨에서 사용, 개발자가 컨트롤이 불가능한 외부 라이브러리 사용 시 주로 사용한다.
- @Component는 클래스 레벨에서 사용, 개발자가 컨트롤이 가능한 내부 클래스에 사용한다.

#### 주제 3: 스프링 Context
- [레퍼런스](https://workshop-6349.tistory.com/entry/Spring-Spring-Context-%EC%84%A4%EB%AA%85)
<img width="706" alt="image" src="https://github.com/user-attachments/assets/4cb6c707-6f25-44de-a814-4365ab35ea60">

- Bean과 스프링 Container사이에 있는, Bean 관리 및 여러 기능들을 가진 공간
- 서블릿 객체는 단독으로 관리되니, 공통 연결을 일일이 할당하는 참사를 막기 위해 공간을 크게 두가지로 구분해두었다.

1. ROOT-CONTEXT(공용)
- 모든 서블릿 Bean들이 공유할 수 있는 공간
- Repository, Service 등 DB와 관련된 부분이 있음
2. SERVLET-CONTEXT(단독)
- 서블릿 각자의 Bean들이 모인 공간
- MVC의 Container

#### 주제 4: @Autowired
- [레퍼런스](https://devlog-wjdrbs96.tistory.com/166)
- 의존성을 주입할 때 사용하는 어노테이션
- 자동으로 의존성을 주입할 대상을 찾기 때문에 간편하지만, 대상이 Bean으로 등록되어 있지 않거나(@Autowired는 Bean중에서 대상을 찾음) 찾지 못하는 경우 애플리케이션 구동에 실패한다.
- (required=false)값을 지정하면 DI시 빈으로 등록되지 않는다.
- setter와 필드에 사용하게 되면 클래스는 빈으로 등록할 수 있지만, 대상은 빈으로 등록할 수 없게 된다.
- 생성자에 사용하게 되면 클래스도 빈으로 등록되지 않는다.
- 인터페이스를 2가지 이상의 클래스에 implement하고 클래스에서 @Autowired를 사용하려면 뒤에 @Primary 어노테이션을 지정해주거나, @Qualifier를 지정해주면 된다.
- 일반적으로 @Primary 방법이 더 안정적이라고 한다.
- @Autowired 어노테이션을 통한 의존성 주입은 BeanPostProcessor라는 빈 라이프 사이클 콜백에 의해 이루어진다.

#### 주제 5: 관점 지향 프로그래밍(AOP)
- [레퍼런스](https://velog.io/@dkwktm45/Spring-AOP%EB%A5%BC-%EC%95%8C%EA%B3%A0-%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%95%8C%EC%9E%90)
- AOP는 관점(핵심 기능, 부가 기능으로 구분)을 기준으로 묶어 개발하는 개발 패러다임이다.
- 핵심 기능은 비즈니스 로직이 처리하려는 목적 기능을 이야기한다.
- Advice는 관점의 구체적인 동작을 정의하여 언제 어떤 동작을 수행할지를 결정한다. 종류는 다음과 같다
  - **@Before** : 메소드 실행 전에 동작을 수행하는 Advice
  - **@After** : 메서드 실행 후에 동작을 수행하는 Advice
  - **@AfterReturning** : 메서드가 성공적으로 반환된 후에 동작을 수행하는 Advice
  - **@AfterThrowing** : 메서드에서 예외가 발생한 후에 동작을 수행하는 Advice
  - **@Around** : 메서드 실행 전후에 동작을 수행하며, 메서드 실행을 직접 제어하는 Advice
- 부가 기능은 로깅, 트랜잭션 관리, 시큐리티, 캐싱, 예외 처리, 성능 모니터링 등의 기능이 있고, Advice를 사용해 언제 처리할지를 정한다.
- 해당 기능들을 핵심 기능이 수행될 때 마다 지정하면 가독성 및 유지보수성이 저하되고, 서비스 로직이 복잡해진다.
- AOP를 사용하면 유지 보수, 상황에 맞는 AOP적용이 쉬워지는 장점이 있다.
- Spring AOP에서는 런타임 중 프록시 객체를 생성하여 관점을 적용하며, 가장 유연한 방식이지만 프록시 생성 오버헤드가 발생한다.

#### 주제 6: 프로젝트 질문 정리
- 질문을 정리하면서 서비스에 대해 고민을 해봤다.
- 웹 소켓과 SSE(Server Sent Event)중 어떤게 실시간 차트 구현에 더 효과적일지 모르겠다.
- 만약 페이지를 옮겼을 때 연결을 재설립하면 SSE가 유리한 것 같고, 옮길때도 연결을 유지하면 웹소켓이 더 좋을 것 같다.


### 오늘의 회고
- 오늘은 공부할 시간이 많아서 좋았다
- Docker도 미리 공부해둬서 ci/cd를 구현할 때 같이 진행해야겠다

### 참고 자료 및 링크
- [캔바](https://www.canva.com/design/DAGLou5ecds/nN17CkgOwou2_sbx0QDWbg/edit)
- [피그마](https://www.figma.com/design/eNCogYI1nbVuMpB6JUOHaT/team2?node-id=1-2)
